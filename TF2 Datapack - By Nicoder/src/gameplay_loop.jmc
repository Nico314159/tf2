Item.create(
    itemId      = selectSniper,
    itemType    = carrot_on_a_stick,
    displayName = "Sniper",
    nbt         = {CustomModelData: Class.SNIPER},
    onClick     = () => {tf2.class:@s = Class.SNIPER; class_select();}
);
Item.create(
    itemId      = selectScout,
    itemType    = carrot_on_a_stick,
    displayName = "Scout",
    nbt         = {CustomModelData: Class.SCOUT},
    onClick     = () => {tf2.class:@s = Class.SCOUT; class_select();}
);
Item.create(
    itemId      = selectHeavy,
    itemType    = carrot_on_a_stick,
    displayName = "Heavy",
    nbt         = {CustomModelData: Class.HEAVY},
    onClick     = () => {tf2.class:@s = Class.HEAVY; class_select();}
);

class start_game {
    class as_marker {
        function main() {
            // Starts a new running game with the players in the queue. ");
            // @within __tick__()

            if ($Settings.show_debug_messages) Text.tellraw(@a, "&<bold><Debug> &<!bold>Game has been started by &<@s> at &<0008it54g_p_join:$__global__> ticks gametime");
            if ($Settings.show_debug_messages >= 2 && $profiler_installed) timekeeper.var:$enabled = -1;
            tf2.batch_number:$local = tf2.batch_number:@s;
            execute store result storage tf2.__temp__:index i int 1 run tf2.batch_number:@s.get();
            execute store result storage tf2.__temp__:index map_id int 1 run tf2.map:@s.get();
            execute run {
                $scoreboard players add $global_$(i) tf2.session 1;
                $scoreboard players operation @s tf2.session = $global_$(i) tf2.session;
                $data modify entity @s data.map set from storage tf2:maps $(map_id);
            } with storage tf2.__temp__:index;

            tf2.gamemode:@s = data get entity @s data.map.gamemode;
            tf2.gamemode:$temp = tf2.gamemode:@s;
            data modify storage tf2.__temp__:summon objectives
                        set from entity @s data.map.objectives;
            tf2.index:$temp = execute if data storage tf2.__temp__:summon objectives[];
            tf2.index:$temp *= 10;
            while (data storage tf2.__temp__:summon objectives[]) {
                tf2.index:$temp -= 10;
                execute summon marker run {
                    // Storage format of `tf2.__temp__:summon objectives[-1]`
                    //      Pos: double[]
                    //          Coordinates of where the objective is located on the map.
                    //      Tags: string[]
                    //          Specifies info about what type of objective it is. (eg: control point, intelligence, payload cart)
                    //      data.team: byte
                    //          Which team starts out as the owner of the point (0 = unowned, 1 = RED, 2 = BLU).
                    //      data.locked: bool
                    //          # DEPRECATED, use the `tf2.locked` tag instead. #
                    //          Whether or not the objective should start out locked.
                    //      data.capture_threshold: float
                    //          Amount of time needed to capture the objective, in *seconds* (converted to *milli-ticks* when in score form).");

                    data modify storage tf2.__temp__:summon entity.Pos
                       set from storage tf2.__temp__:summon objectives[-1].Pos;
                    data modify storage tf2.__temp__:summon entity.Tags
                       set from storage tf2.__temp__:summon objectives[-1].Tags;
                    data modify entity @s {} merge from storage tf2.__temp__:summon entity;
                    tf2.team:@s              = data get storage tf2.__temp__:summon objectives[-1].data.team 1;
                    tf2.capture_threshold:@s = data get storage tf2.__temp__:summon objectives[-1].data.capture_threshold 20000;
                    tf2.increment:@s         = data get storage tf2.__temp__:summon objectives[-1].data.increment 20;
                    tf2.gamemode:@s          = tf2.gamemode:$temp;
                    tf2.index:@s             = tf2.index:$temp;
                    tf2.index:$highest > tf2.index:@s;
                    tf2.batch_number:@s = tf2.batch_number:$local;
                    tf2.red_progress:@s[scores={tf2.team=1}] = tf2.capture_threshold:@s;
                    tf2.blu_progress:@s[scores={tf2.team=2}] = tf2.capture_threshold:@s;
                    execute if score @s tf2.index = $highest tf2.index run tag @s add tf2.last;
                    tag @s[scores={tf2.index=0,tf2.gamemode=2}] add tf2.last;
                    $scoreboard players operation @s tf2.session = $global_$(i) tf2.session;
                } with storage tf2.__temp__:index;
                data remove storage tf2.__temp__:summon objectives[-1];
            }
            if (tf2.gamemode:@s matches 1..4) Objectives.control_point.visuals.spacing();
            data remove entity @s data.map.objectives;
            data remove storage tf2.__temp__:summon entity;

            execute as @e[type=marker,tag=tf2.control_point,scores={tf2.team=1}] at @s run setblock ~ ~-1 ~ red_stained_glass;
            execute as @e[type=marker,tag=tf2.control_point,scores={tf2.team=2}] at @s run setblock ~ ~-1 ~ blue_stained_glass;

            // TODO: replace random assignment with "first come, first serve"
            if ($comp_queue_length >= 12) {
                execute as @e[type=#tf2:player_like,tag=tf2.in_queue,scores={tf2.queue_type=1,tf2.batch_number=0},limit=12,sort=random] run start_game.as_players.generic();
            }
            else if ($casual_queue_length >= 24) {
                execute as @e[type=#tf2:player_like,tag=tf2.in_queue,scores={tf2.queue_type=2,tf2.batch_number=0},limit=24,sort=random] run start_game.as_players.generic();
            }
            else if ($chaos_queue_length >= 40) {
                execute as @e[type=#tf2:player_like,tag=tf2.in_queue,scores={tf2.queue_type=3,tf2.batch_number=0},limit=40,sort=random] run start_game.as_players.generic();
            }
            scoreboard players operation @s tf2.queue_type = @e[type=#tf2:player_like,tag=tf2.current,limit=1] tf2.queue_type;
            if (tf2.gamemode:@s matches 1..2) {
                tf2.timer:@s = data get entity @s data.map.timer 20;
                if (data entity @s data.map.timer) Timer.set_max() with storage tf2.__temp__:index;
                if (data entity @s data.map.timer) Timer.show() with storage tf2.__temp__:index;
                if (data entity @s data.map.setup_time) Timer.begin_setup();
            }
            if (tf2.gamemode:@s == 3) {
                tf2.team:@s = 0;
                scoreboard players reset @s tf2.timer; // failsafe, shouldn't actually be necessary ever
                KOTH_Timer.set_max() with storage tf2.__temp__:index;
                KOTH_Timer.show() with storage tf2.__temp__:index;
            }
            start_game.as_marker.tell_info();

            scoreboard players reset @e[tag=tf2.current] tf2.team;
            $team_temp = 0;
            $count = execute if entity @e[tag=tf2.current];
            execute as @e[tag=tf2.current,sort=random] run team_assign();
            $count %= 2; // in case of an odd player count, the extra player has a 50/50 change of going to either team
            if ($count = 1 && predicate tf2:coin_flip) {tf2.team:@e[tag=tf2.current,sort=random,limit=1,scores={tf2.team=1}] = 2;}
            tag @s add tf2.in_use;
            tag @e remove tf2.current;
        } function tell_info() {
            // [WIP] Tells players which gamemode they will be playing, and some basic info about how that gamemode works.
            // @within start_game.as_marker.main()

            // (1 = A/D, 2 = 5CP, 3 = KOTH, etc.)
            if (tf2.gamemode:@s = 1) Text.tellraw(@a[tag=tf2.current], "&<bold, underlined>Gamemode:&<!underlined> &<italic, info_atk_def>Attack / Defend");
            if (tf2.gamemode:@s = 2) Text.tellraw(@a[tag=tf2.current], "&<bold, underlined>Gamemode:&<!underlined> &<italic, info_control_points>Control Points");
        }
    }
    class as_players {
        function generic(){
            // Adds players to the game and gives them a tag so that other functions know.
            // @within start_game.as_marker.main()

            effect give @s glowing 1000 0 true;
            // if ($Settings.show_debug_messages) say generic
            tf2.batch_number:@s = tf2.batch_number:$local;
            tag @s remove tf2.in_queue;
            tag @s add tf2.is_playing;

            // placeholder until all 9 classes are properly implemented
            tf2.max_health:@s ??= 100;
            tf2.health:@s = tf2.max_health:@s;

            // tag is used for team assignment
            tag @s add tf2.current;
            tf2.respawn_timer:@s = 0;

            // apply gametype-specific settings
            if (tf2.queue_type:@s = 1) start_game.as_players.competitive();
            if (tf2.queue_type:@s = 2) start_game.as_players.casual();
            if (tf2.queue_type:@s = 3) start_game.as_players.chaos();
        } function casual() {
            // if ($Settings.show_debug_messages) say casual
            tag @s add tf2.random_spread;
            tag @s remove tf2.random_crits;
            tag @s add tf2.free_vote;
            tag @s add tf2.can_be_autobalanced;
        } function competitive() {
            // if ($Settings.show_debug_messages) say competitive
            tag @s remove tf2.random_spread;
            tag @s remove tf2.random_crits;
            tag @s remove tf2.free_vote;
            tag @s add tf2.can_be_autobalanced;
        } function chaos() {
            // if ($Settings.show_debug_messages) say chaos
            tag @s add tf2.random_spread;
            tag @s add tf2.random_crits;
            tag @s add tf2.free_vote;
            tag @s remove tf2.can_be_autobalanced;
        }
    }
}

TextProp.hoverText(
    "stalemate_text",
    "You're &<bold>all losers!"
);
class reset {
    function announce_winner() {
        // Announces the winner of the game, but doesn't relog players yet.
        // @within:
        //   Objectives.control_point.gamestate()
        //   Timer.end_game()

        // if ($Settings.show_debug_messages) tellraw Nico314 ["",{"text":"<Debug> ","bold":true},{"score":{"name":"$red_cp_count","objective":"tf2.var"},"color":"red"},{"text":", ","color":"red"},{"score":{"name":"$blu_cp_count","objective":"tf2.var"},"color":"blue"},{"text":", ","color":"blue"},{"score":{"name":"@s","objective":"tf2.index"}}]
        execute as @e if score @s tf2.batch_number = $local tf2.batch_number run tag @s add tf2.current;
        execute as @e[type=marker,tag=tf2.control_point,tag=tf2.current] at @s run Objectives.control_point.lock();
        kill @e[type=villager,tag=tf2.current];
        if ($winner == 1) Text.tellraw(@a[tag=tf2.current], "&<yellow>MATCH &<white>| &<red,bold,italic>RED wins!");
        if ($winner == 2) Text.tellraw(@a[tag=tf2.current], "&<yellow>MATCH &<white>| &<blue,bold,italic>BLU wins!");
        if ($winner == -1) Text.tellraw(@a[tag=tf2.current], "&<gray,italic,stalemate_text>Stalemate....");

        execute as @a[tag=tf2.current] run {
            if (tf2.team:@s == $winner) Text.tellraw(@s, "&<!bold,italic>Victory.");
            else if ($winner matches 1..2) Text.tellraw(@s, "&<!bold,italic>You've failed!");
        }
        execute store result storage tf2.__temp__:index i int 1 run tf2.batch_number:@s.get();
        if (tf2.gamemode:@s matches 1..2) Timer.hide() with storage tf2.__temp__:index;
        if (tf2.gamemode:@s == 3) KOTH_Timer.hide() with storage tf2.__temp__:index;
        tf2.timer:@s = -1;
        tag @a remove tf2.current;
    } function as_marker() {
        // Resets gameplay-specific information once a match ends.
        // @within Timer.main()

        if ($Settings.show_debug_messages = 1) Text.tellraw(@a, "&<bold><Debug> &<!bold>Game controlled by &<@s> has ended at &<0008it54g_p_join:$__global__> ticks gametime");
        tf2.batch_number:$local = tf2.batch_number:@s;
        execute as @e if score @s tf2.batch_number = $local tf2.batch_number run tag @s add tf2.current;
        execute as @e[type=marker,tag=tf2.control_point,tag=tf2.current] at @s run reset.as_objectives();
        execute as @a[tag=tf2.current] run reset.as_players();
        if (timekeeper.var:$enabled == -1 && $profiler_installed) timekeeper.var:$enabled = 1;
        kill @s;
        setup_markers();
    } function as_objectives() {
        // Resets all objective data when a match ends, and kills the Objectives.
        // @within reset.as_marker()

        setblock ~ ~-1 ~ glass;
        setblock ~ ~ ~ air;
        Objectives.control_point.find_index.main();
        Hardcode.repeatList(
            "key",
            () => {data modify storage tf2.__temp__:lookup points[0].key set value '[""]';},
            ["owner", "progress", "symbol", "extra"]
        );
        Objectives.control_point.find_index.reinsert();
        kill @s;
    } function as_players() {
        // Adds to players' permanent statistics, then relogs them.
        // @within reset.as_marker()

        if (tf2.team:@s == $winner) tf2.permanent.games_won:@s ++;
        tf2.permanent.games_played:@s ++;
        tag @s remove tf2.current;
        0008it54g_p_join:@s --;
        kill @s[type=villager]; // debug only
    }
}

function test_items() {
    Item.give(selectSniper, @s);
    Item.give(selectScout,  @s);
    Item.give(selectHeavy,  @s);
}

function quick_start() {
    Hardcode.repeat("never", () => {
        summon blaze ~ ~ ~ {NoAI: 1b};
    }, start=1, stop=12);
    tf2.queue_type:@e[type=blaze,limit=11] = 1;
}