Item.create(
    itemId      = selectSniper,
    itemType    = carrot_on_a_stick,
    displayName = "Sniper",
    nbt         = {CustomModelData: Class.SNIPER},
    onClick     = () => {tf2.class:@s = Class.SNIPER; class_select();}
);
Item.create(
    itemId      = selectScout,
    itemType    = carrot_on_a_stick,
    displayName = "Scout",
    nbt         = {CustomModelData: Class.SCOUT},
    onClick     = () => {tf2.class:@s = Class.SCOUT; class_select();}
);
Item.create(
    itemId      = selectHeavy,
    itemType    = carrot_on_a_stick,
    displayName = "Heavy",
    nbt         = {CustomModelData: Class.HEAVY},
    onClick     = () => {tf2.class:@s = Class.HEAVY; class_select();}
);

class start_game {
    class as_marker {
	    @lazy function summon_entities() {
            // Objectives
	        data modify storage tf2.__temp__:summon objectives
	                    set from entity @s data.map.objectives;
	        tf2.index:$temp = data get storage tf2.__temp__:summon objectives;
	        tf2.index:$temp *= 10;
	        while (data storage tf2.__temp__:summon objectives[]) {
	            tf2.index:$temp -= 10;
	            execute summon marker run {
	                // Storage format of `tf2.__temp__:summon objectives[-1]`
	                //      Pos: double[]
	                //          Coordinates of where the objective is located on the map.
	                //      Tags: string[]
	                //          Specifies info about what type of objective it is. (eg: control point, intelligence, payload cart)
	                //      data.team: byte
	                //          Which team starts out as the owner of the point (0 = unowned, 1 = RED, 2 = BLU).
	                //      data.locked: bool
	                //          # DEPRECATED, use the `tf2.locked` tag instead. #
	                //          Whether or not the objective should start out locked.
	                //      data.capture_threshold: float
	                //          Amount of time needed to capture the objective, in *seconds* (converted to *milli-ticks* when in score form).");

	                data modify storage tf2.__temp__:summon entity.Pos
	                     set from storage tf2.__temp__:summon objectives[-1].Pos;
	                data modify storage tf2.__temp__:summon entity.Tags
	                     set from storage tf2.__temp__:summon objectives[-1].Tags;
	                data modify entity @s {} merge from storage tf2.__temp__:summon entity;
	                tf2.team:@s              = data get storage tf2.__temp__:summon objectives[-1].data.team 1;
	                tf2.capture_threshold:@s = data get storage tf2.__temp__:summon objectives[-1].data.capture_threshold 20000;
	                tf2.increment:@s         = data get storage tf2.__temp__:summon objectives[-1].data.increment 20;
	                tf2.gamemode:@s          = tf2.gamemode:$temp;
	                tf2.index:@s             = tf2.index:$temp;
	                tf2.index:$highest > tf2.index:@s;
	                tf2.batch_number:@s = tf2.batch_number:$local;
	                tf2.red_progress:@s[scores={tf2.team=1}] = tf2.capture_threshold:@s;
	                tf2.blu_progress:@s[scores={tf2.team=2}] = tf2.capture_threshold:@s;
	                execute if score @s tf2.index = $highest tf2.index
                            unless score @s tf2.gamemode matches 3 run tag @s add tf2.last;
	                tag @s[scores={tf2.index=0,tf2.gamemode=2}] add tf2.last;
	                $scoreboard players operation @s tf2.session = $global_$(i) tf2.session;
	            } with storage tf2.__temp__:index;
	            data remove storage tf2.__temp__:summon objectives[-1];
	        }
            data remove storage tf2.__temp__:summon entity;

            // Spawn doors
            data modify storage tf2.__temp__:summon doors
	                    set from entity @s data.map.spawn_doors.red;
            data modify storage tf2.__temp__:summon doors
	                    append from entity @s data.map.spawn_doors.blu[];
	        $blu_length = data get entity @s data.map.spawn_doors.blu;
	        $i = 0;
	        while (data storage tf2.__temp__:summon doors[]) {
	            execute summon marker run {
	                // Storage format of `tf2.__temp__:summon doors[-1]`
	                //      Pos: double[3]
	                //          Coordinates of where the door is located on the map.
	                //      Rotation: float[2]
	                //          How the door entity is rotated (affects teleport command)
	                //      data.dx/y/z: int
	                //          How large the detection box is in each dimension

	                data modify storage tf2.__temp__:summon entity.Pos
	                     set from storage tf2.__temp__:summon doors[-1].Pos;
	                data modify storage tf2.__temp__:summon entity.Rotation
	                     set from storage tf2.__temp__:summon doors[-1].Rotation;
                    data modify storage tf2.__temp__:summon entity.data
	                     set from storage tf2.__temp__:summon doors[-1].data;

                    $direct_tp = data get storage tf2.__temp__:summon entity.data.direct_tp;
                    if (!$direct_tp) expand {
                        tag @s add tf2.visible;
                        data modify storage tf2.__temp__:summon entity.data.direct_tp set value "~ ~ ~";
                    }

                    $opp_team ?= execute if score $i tf2.var >= $blu_length tf2.var;
                    $opp_team ++;
                    execute store result storage tf2.__temp__:summon entity.data.opp_team int 1 run $opp_team.get();
	                data modify entity @s {} merge from storage tf2.__temp__:summon entity;
                    tf2.batch_number:@s = tf2.batch_number:$local;
            	    tag @s add tf2.spawn_door;
	            } with storage tf2.__temp__:index;
	            data remove storage tf2.__temp__:summon doors[-1];
	            $i++;
	        }
	        data remove storage tf2.__temp__:summon entity;

            // Pickups (health & ammo)
            data modify storage tf2.__temp__:summon pickups
                        set from entity @s data.map.pickups;
            while (data storage tf2.__temp__:summon pickups[]) {
                execute summon item_display run {
                    // Storage format of `tf2.__temp__:summon pickups[-1]`
	                //      Pos: double[3]
	                //          Coordinates of where the pickup is located on the map.
	                //      kind: string
	                //          Whether it is a health or ammo pack.
	                //      size: byte
	                //          1 = small (refills 20%), 2 = medium (refills 50%), 3 = large (refills 100%)

                    data modify storage tf2.__temp__:summon entity.Pos
	                     set from storage tf2.__temp__:summon pickups[-1].Pos;
                    data modify storage tf2.__temp__:summon entity.item.id
	                     set value "iron_ingot";
                    data modify storage tf2.__temp__:summon entity.item.Count
	                     set value 1b;
                    data modify storage tf2.__temp__:summon entity.transformation
                         set value {translation: [0.0f, 1.0f, 0.0f]};
                    execute run { $tag @s add tf2.$(kind)_pack; }
                            with storage tf2.__temp__:summon pickups[-1];

                    tf2.size:@s = data get storage tf2.__temp__:summon pickups[-1].size;
                    data modify entity @s {} merge from storage tf2.__temp__:summon entity;
                    tf2.batch_number:@s = tf2.batch_number:$local;
                    tag @s add tf2.pickup;
                }
                data remove storage tf2.__temp__:summon pickups[-1];
            }
            data remove storage tf2.__temp__:summon entity;

            // Resupply cabinets
            data modify storage tf2.__temp__:summon resupply
                        set from entity @s data.map.resupply_cabinets.red;
            data modify storage tf2.__temp__:summon resupply
	                    append from entity @s data.map.resupply_cabinets.blu[];
	        $blu_length = data get entity @s data.map.resupply_cabinets.blu;
	        $i = 0;
            while (data storage tf2.__temp__:summon resupply[]) {
                execute summon item_display run {
                    // Storage format of `tf2.__temp__:summon resupply[-1]`
	                //      Pos: double[3]
	                //          Coordinates of where the resupply cabinet is located on the map.
	                //      Rotation: float[2]
	                //          Which way the resupply cabinet is facing.

                    data modify storage tf2.__temp__:summon entity.Pos
	                     set from storage tf2.__temp__:summon resupply[-1].Pos;
                    data modify storage tf2.__temp__:summon entity.Rotation
	                     set from storage tf2.__temp__:summon resupply[-1].Rotation;
                    data modify storage tf2.__temp__:summon entity.item.id
	                     set value "gold_ingot";
                    data modify storage tf2.__temp__:summon entity.item.Count
	                     set value 1b;

                    tf2.team:@s ?= execute if score $i tf2.var < $blu_length tf2.var;
                    tf2.team:@s ++;
                    data modify entity @s {} merge from storage tf2.__temp__:summon entity;
                    tf2.batch_number:@s = tf2.batch_number:$local;
                    tag @s add tf2.resupply;
                }
                data remove storage tf2.__temp__:summon resupply[-1];
                $i++;
            }
            data remove storage tf2.__temp__:summon entity;
	    }
        function main() {
            // Starts a new running game with the players in the queue. ");
            // @within __tick__()

            if ($Settings.show_debug_messages) Text.tellraw(@a, "&<bold><Debug> &<!bold>Game has been started by &<@s> at &<0008it54g_p_join:$__global__> ticks gametime");
            if ($Settings.show_debug_messages >= 2 && $profiler_installed) timekeeper.var:$enabled = -1;
            tf2.batch_number:$local = tf2.batch_number:@s;
            execute store result storage tf2.__temp__:index i int 1 run tf2.batch_number:@s.get();
            execute store result storage tf2.__temp__:index map_id int 1 run tf2.map:@s.get();
            execute run {
                $scoreboard players add $global_$(i) tf2.session 1;
                $scoreboard players operation @s tf2.session = $global_$(i) tf2.session;
                $data modify entity @s data.map set from storage tf2:maps $(map_id);
                $data modify storage tf2:running_games $(i) set from storage tf2:maps $(map_id);
            } with storage tf2.__temp__:index;

            tf2.gamemode:@s = data get entity @s data.map.gamemode;
            tf2.gamemode:$temp = tf2.gamemode:@s;
            this.summon_entities();
            if (tf2.gamemode:@s matches 1..4) Objectives.control_point.visuals.spacing();

            execute as @e[type=marker,tag=tf2.control_point,scores={tf2.team=1}] at @s run setblock ~ ~-1 ~ red_stained_glass;
            execute as @e[type=marker,tag=tf2.control_point,scores={tf2.team=2}] at @s run setblock ~ ~-1 ~ blue_stained_glass;

            // TODO: replace random assignment with "first come, first serve"
            if ($comp_queue_length >= 12) {
                execute as @e[type=#tf2:player_like,tag=tf2.in_queue,scores={tf2.queue_type=1,tf2.batch_number=0},limit=12,sort=random] run start_game.as_players.generic();
            }
            else if ($casual_queue_length >= 24) {
                execute as @e[type=#tf2:player_like,tag=tf2.in_queue,scores={tf2.queue_type=2,tf2.batch_number=0},limit=24,sort=random] run start_game.as_players.generic();
            }
            else if ($chaos_queue_length >= 40) {
                execute as @e[type=#tf2:player_like,tag=tf2.in_queue,scores={tf2.queue_type=3,tf2.batch_number=0},limit=40,sort=random] run start_game.as_players.generic();
            }
            scoreboard players operation @s tf2.queue_type = @e[type=#tf2:player_like,tag=tf2.current,limit=1] tf2.queue_type;
            if (tf2.gamemode:@s matches 1..2) {
                tf2.timer:@s = data get entity @s data.map.timer 20;
                if (data entity @s data.map.timer) Timer.set_max() with storage tf2.__temp__:index;
                if (data entity @s data.map.timer) Timer.show() with storage tf2.__temp__:index;
                if (data entity @s data.map.setup_time) Timer.begin_setup();
            }
            if (tf2.gamemode:@s == 3) {
                tf2.team:@s = 0;
                scoreboard players reset @s tf2.timer; // failsafe, shouldn't actually be necessary ever
                KOTH_Timer.set_max() with storage tf2.__temp__:index;
                KOTH_Timer.show() with storage tf2.__temp__:index;
            }
            start_game.as_marker.tell_info();

            scoreboard players reset @e[tag=tf2.current] tf2.team;
            $team_temp = 0;
            $count = execute if entity @e[tag=tf2.current];
            execute as @e[tag=tf2.current,sort=random] run team_assign();
            $count %= 2; // in case of an odd player count, the extra player has a 50/50 change of going to either team
            if ($count = 1 && predicate tf2:coin_flip) {tf2.team:@e[tag=tf2.current,sort=random,limit=1,scores={tf2.team=1}] = 2;}
            tag @s add tf2.in_use;
            tag @e remove tf2.current;
        } function tell_info() {
            // [WIP] Tells players which gamemode they will be playing, and some basic info about how that gamemode works.
            // @within start_game.as_marker.main()

            // (1 = A/D, 2 = 5CP, 3 = KOTH, etc.)
            if (tf2.gamemode:@s = 1) Text.tellraw(@a[tag=tf2.current], "&<bold, underlined>Gamemode:&<!underlined> &<italic, info_atk_def>Attack / Defend");
            if (tf2.gamemode:@s = 2) Text.tellraw(@a[tag=tf2.current], "&<bold, underlined>Gamemode:&<!underlined> &<italic, info_control_points>Control Points");
        }
    }
    class as_players {
        function generic(){
            // Adds players to the game and gives them a tag so that other functions know.
            // @within start_game.as_marker.main()

            effect give @s glowing 1000 0 true;
            // if ($Settings.show_debug_messages) say generic
            tf2.batch_number:@s = tf2.batch_number:$local;
            tag @s remove tf2.in_queue;
            tag @s add tf2.is_playing;

            // placeholder until all 9 classes are properly implemented
            tf2.max_health:@s ??= 100;
            tf2.health:@s = tf2.max_health:@s;

            // tag is used for team assignment
            tag @s add tf2.current;
            tf2.respawn_timer:@s = 0;

            // apply gametype-specific settings
            if (tf2.queue_type:@s = 1) start_game.as_players.competitive();
            if (tf2.queue_type:@s = 2) start_game.as_players.casual();
            if (tf2.queue_type:@s = 3) start_game.as_players.chaos();
        } function casual() {
            // if ($Settings.show_debug_messages) say casual
            tag @s add tf2.random_spread;
            tag @s remove tf2.random_crits;
            tag @s add tf2.free_vote;
            tag @s add tf2.can_be_autobalanced;
        } function competitive() {
            // if ($Settings.show_debug_messages) say competitive
            tag @s remove tf2.random_spread;
            tag @s remove tf2.random_crits;
            tag @s remove tf2.free_vote;
            tag @s add tf2.can_be_autobalanced;
        } function chaos() {
            // if ($Settings.show_debug_messages) say chaos
            tag @s add tf2.random_spread;
            tag @s add tf2.random_crits;
            tag @s add tf2.free_vote;
            tag @s remove tf2.can_be_autobalanced;
        }
    }
}

TextProp.hoverText(
    "stalemate_text",
    "You're &<bold>all losers!"
);
class reset {
    function announce_winner() {
        // Announces the winner of the game, but doesn't relog players yet.
        // @within:
        //   Objectives.control_point.gamestate()
        //   Timer.end_game()

        // if ($Settings.show_debug_messages) tellraw Nico314 ["",{"text":"<Debug> ","bold":true},{"score":{"name":"$red_cp_count","objective":"tf2.var"},"color":"red"},{"text":", ","color":"red"},{"score":{"name":"$blu_cp_count","objective":"tf2.var"},"color":"blue"},{"text":", ","color":"blue"},{"score":{"name":"@s","objective":"tf2.index"}}]
        // if ($Settings.show_debug_messages = 1) Text.tellraw(@a, "&<bold><Debug> &<!bold>Announced at &<0008it54g_p_join:$__global__> ticks gametime");
        execute as @e if score @s tf2.batch_number = $local tf2.batch_number run tag @s add tf2.current;
        execute as @e[type=marker,tag=tf2.control_point,tag=tf2.current] at @s run Objectives.control_point.lock();
        kill @e[type=villager,tag=tf2.current];
        if ($winner == 1) Text.tellraw(@a[tag=tf2.current], "&<yellow>MATCH &<white>| &<red,bold,italic>RED wins!");
        if ($winner == 2) Text.tellraw(@a[tag=tf2.current], "&<yellow>MATCH &<white>| &<blue,bold,italic>BLU wins!");
        if ($winner == -1) Text.tellraw(@a[tag=tf2.current], "&<gray,italic,stalemate_text>Stalemate....");

        execute as @a[tag=tf2.current] run {
            if (tf2.team:@s == $winner) Text.tellraw(@s, "&<!bold,italic>Victory.");
            else if ($winner matches 1..2) Text.tellraw(@s, "&<!bold,italic>You've failed!");
        }
        tf2.timer:@s = -1;
        tag @a remove tf2.current;
    } function as_marker() {
        // Resets gameplay-specific information once a match ends.
        // @within Timer.main()

        if ($Settings.show_debug_messages = 1) Text.tellraw(@a, "&<bold><Debug> &<!bold>Game controlled by &<@s> has ended at &<0008it54g_p_join:$__global__> ticks gametime");
        execute store result storage tf2.__temp__:index i int 1 run tf2.batch_number:@s.get();
        if (tf2.gamemode:@s matches 1..2) Timer.hide() with storage tf2.__temp__:index;
        if (tf2.gamemode:@s == 3) KOTH_Timer.hide() with storage tf2.__temp__:index;
        tf2.batch_number:$local = tf2.batch_number:@s;
        execute as @e if score @s tf2.batch_number = $local tf2.batch_number run tag @s add tf2.current;
        execute as @e[type=marker,tag=tf2.control_point,tag=tf2.current] at @s run reset.as_objectives();
        execute as @a[tag=tf2.current] run reset.as_players();
        kill @e[type=item_display,tag=tf2.current,tag=!tf2.permanent];
        if (timekeeper.var:$enabled == -1 && $profiler_installed) timekeeper.var:$enabled = 1;
        kill @s;
        setup_markers();
    } function as_objectives() {
        // Resets all objective data when a match ends, and kills the Objectives.
        // @within reset.as_marker()

        setblock ~ ~-1 ~ glass;
        setblock ~ ~ ~ air;
        Objectives.control_point.find_index.main();
        Hardcode.repeatList(
            "key",
            () => {data modify storage tf2.__temp__:lookup points[0].key set value '[""]';},
            ["owner", "progress", "symbol", "extra"]
        );
        Objectives.control_point.find_index.reinsert();
        kill @s;
    } function as_players() {
        // Adds to players' permanent statistics, then relogs them.
        // @within reset.as_marker()

        if (tf2.team:@s == $winner) tf2.permanent.games_won:@s ++;
        tf2.permanent.games_played:@s ++;
        tag @s remove tf2.current;
        0008it54g_p_join:@s --;
        kill @s[type=villager]; // debug only
    }
}

function test_items() {
    Item.give(selectSniper, @s);
    Item.give(selectScout,  @s);
    Item.give(selectHeavy,  @s);
}

function quick_start() {
    Hardcode.repeat("never", () => {
        summon blaze ~ ~ ~ {NoAI: 1b};
    }, start=1, stop=12);
    tf2.queue_type:@e[type=blaze,limit=11] = 1;
}